given       -- определяет, что будет отправлено в запросе,
when        -- с каким методом и на какой эндпоинт отправляем запрос,
get         -- получение запроса ответа с эндпоинта
then        -- как проверяется пришедший ответ.
and         -- союз
filter      -- фильтр применяется до основных шагов
extract     -- получение данных из
body        -- тело с параметрами (JSON, XML)
pathParam   -- параметры. Имя параметра, значение

Response response = get("/lotto");

// Get all headers
Headers allHeaders = response.getHeaders();

// Get a single header value:
String headerName = response.getHeader("headerName");

// Get all cookies as simple name-value pairs
Map<String, String> allCookies = response.getCookies();

// Get a single cookie value:
String cookieValue = response.getCookie("cookieName");

// Get status line
String statusLine = response.getStatusLine();

// Get status code
int statusCode = response.getStatusCode();

Кроме этого, можно извлечь тело ответа в виде объекта типа JsonPath или XmlPath,
 чтобы потом использовать полученные данные.

Терминальными методами являются только методы, вызываемые после метода extract():
...then().statusCode(200).extract().body().asString();

------------------------------------------------------------------------------------------------------------------------
Не стоит преобразовывать свои POJO в JSON при помощи Jackson ObjectMapper'а,
а потом полученную строку передавать в тело запроса.
REST-assured прекрасно справляется с этой задачей.
Для этого используется всё тот же Jackson или Gson, в зависимости от того, что находится в classpath.
Для преобразования в XML используется JAXB. Исходный формат определяется автоматически по значению Content-Type.

given().contentType(ContentType.JSON).body(somePojo)
    .when().post(EndPoints.add)
    .then()
    .statusCode(201);

то же самое работает и в обратную сторону:
SomePojo pojo = given().
    .when().get(EndPoints.get)
    .then().extract().body().as(SomePojo.class);

------------------------------------------------------------------------------------------------------------------------
Сама библиотека REST-assured написана на Groovy и позволяет вам
применять различные методы из Groovy к полученному JSON/XML ответу. Например:

методы find, findAll применяются к коллекции для поиска первого и всех вхождений,
метод collect для  создания новой коллекции из найденных результатов.

переменная it создается неявно и указывает на текущий элемент коллекции
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.find { it.title =~ 'anythingRegExp'}");

можете явно задать название переменной, указывающей на текущий элемент
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.findAll { element -> element.title.length() > 4 }");

вы можете использовать методы sum, max, min для суммирования всех значений коллекции,
а также поиска максимального и минимально значения
String expensiveCar =
get(EndPoints.cars).path("cars.find { it.title == 'Toyota Motor Corporation'}.models.max { it.averagePrice }.title");

------------------------------------------------------------------------------------------------------------------------
Если ваша задача только осуществить проверку полученного ответа, то необходимости в десериализации точно нет.
REST-assured и Hamcrest позволяют осуществить любую проверку.
Если же вам необходимо в дальнейшем каким-то образом работать с сущностью, полученной в ответе,
то можно воспользоваться десериализацией.

------------------------------------------------------------------------------------------------------------------------
Это произошло из-за того, что REST Assured по-разному справляется с переопределениями для параметров запроса (с ответом то же самое).
Заголовки или фильтры добавляются в список, а потом по очереди применяются.
URI может быть только один, поэтому применяется последний заданный.
В последней добавленной спецификации его не задали — поэтому REST Assured переопределяет его дефолтным значением (localhost).

Если добавляете к запросу спецификацию — добавляйте одну.
Совет кажется очевидным, но когда проект с тестами разрастается, возникают классы-хэлперы и базовые тестовые классы,
внутри них появляются before-методы. Уследить за тем, что на самом деле происходит с вашим запросом, становится сложно,
особенно если тесты пишет сразу несколько человек.

------------------------------------------------------------------------------------------------------------------------